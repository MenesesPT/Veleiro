/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*                                                      */
/* File:  Level1.c                                      */
/*                                                      */
/* Author: Automatically generated by Xfuzzy            */
/*                                                      */
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

#include "Level1.hpp"

#include <math.h>
#include <stdio.h>

/*======================================================*/
/*  Common function to compute a fuzzy number           */
/*======================================================*/

static double compute(FuzzyNumber fn, double x) {
  int length = fn.length;
  int i;
  double imp = fn.imp(fn.degree[0], fn.conc[0].equal(x));
  double mu = imp;

  for (i = 1; i < length; i++) {
    imp = fn.imp(fn.degree[i], fn.conc[i].equal(x));
    mu = fn.also(mu, imp);
  }
  return mu;
}

/*======================================================*/
/*  MembershipFunction MF_xfl_trapezoid                 */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_trapezoid_equal(double x, double min, double max, double step, double a, double b, double c, double d) {
  return (x < a || x > d ? 0 : (x < b ? (x - a) / (b - a) : (x < c ? 1 : (d - x) / (d - c))));
}

/*======================================================*/
/*  MembershipFunction MF_xfl_triangle                  */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_triangle_equal(double x, double min, double max, double step, double a, double b, double c) {
  return (a < x && x <= b ? (x - a) / (b - a) : (b < x && x < c ? (c - x) / (c - b) : 0));
}

/*======================================================*/
/*  Operatorset OP__default_                            */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the operator AND                      */
/*------------------------------------------------------*/

static double OP__default__And(double a, double b) { return (a < b ? a : b); }

/*------------------------------------------------------*/
/* Description of the operator ALSO                     */
/*------------------------------------------------------*/

static double OP__default__Also(double a, double b) { return (a > b ? a : b); }

/*------------------------------------------------------*/
/* Description of the operator IMPLICATION              */
/*------------------------------------------------------*/

static double OP__default__Imp(double a, double b) { return (a < b ? a : b); }

/*------------------------------------------------------*/
/* Description of the defuzzification method            */
/*------------------------------------------------------*/

static double OP__default__Defuz(FuzzyNumber mf) {
  double min = mf.min;
  double max = mf.max;
  double step = mf.step;
  double x, m, num = 0, denom = 0;
  for (x = min; x <= max; x += step) {
    m = compute(mf, x);
    num += x * m;
    denom += m;
  }
  if (denom == 0) return (min + max) / 2;
  return num / denom;
}

/*======================================================*/
/*  Type TP_angulo_correcao                             */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label tudo_esquerda               */
/*------------------------------------------------------*/

static double TP_angulo_correcao_tudo_esquerda_equal(double x) {
  return MF_xfl_trapezoid_equal(x, -180.0, 180.0, 1.0, -213.75, -180.0, -101.25, -67.5);
}

/*------------------------------------------------------*/
/* Description of the label esquerda                    */
/*------------------------------------------------------*/

static double TP_angulo_correcao_esquerda_equal(double x) { return MF_xfl_triangle_equal(x, -180.0, 180.0, 1.0, -101.25, -67.5, -33.75); }

/*------------------------------------------------------*/
/* Description of the label pouco_esquerda              */
/*------------------------------------------------------*/

static double TP_angulo_correcao_pouco_esquerda_equal(double x) { return MF_xfl_triangle_equal(x, -180.0, 180.0, 1.0, -67.5, -33.75, 0.0); }

/*------------------------------------------------------*/
/* Description of the label centrado                    */
/*------------------------------------------------------*/

static double TP_angulo_correcao_centrado_equal(double x) { return MF_xfl_triangle_equal(x, -180.0, 180.0, 1.0, -11.25, 0.0, 11.25); }

/*------------------------------------------------------*/
/* Description of the label pouco_direita               */
/*------------------------------------------------------*/

static double TP_angulo_correcao_pouco_direita_equal(double x) { return MF_xfl_triangle_equal(x, -180.0, 180.0, 1.0, 0.0, 33.75, 67.5); }

/*------------------------------------------------------*/
/* Description of the label direita                     */
/*------------------------------------------------------*/

static double TP_angulo_correcao_direita_equal(double x) { return MF_xfl_triangle_equal(x, -180.0, 180.0, 1.0, 33.75, 67.5, 101.25); }

/*------------------------------------------------------*/
/* Description of the label tudo_direita                */
/*------------------------------------------------------*/

static double TP_angulo_correcao_tudo_direita_equal(double x) {
  return MF_xfl_trapezoid_equal(x, -180.0, 180.0, 1.0, 67.5, 101.25, 180.0, 213.75);
}

/*======================================================*/
/*  Type TP_Cata_vento                                  */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label proa                        */
/*------------------------------------------------------*/

static double TP_Cata_vento_proa_equal(double x) { return MF_xfl_trapezoid_equal(x, 0.0, 180.0, 1.0, -45.0, 0.0, 45.0, 90.0); }

/*------------------------------------------------------*/
/* Description of the label traves                      */
/*------------------------------------------------------*/

static double TP_Cata_vento_traves_equal(double x) { return MF_xfl_triangle_equal(x, 0.0, 180.0, 1.0, 45.0, 90.0, 135.0); }

/*------------------------------------------------------*/
/* Description of the label re                          */
/*------------------------------------------------------*/

static double TP_Cata_vento_re_equal(double x) { return MF_xfl_trapezoid_equal(x, 0.0, 180.0, 1.0, 90.0, 135.0, 180.0, 225.0); }

/*======================================================*/
/*  Type TP_Leme                                        */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label tudo_bombordo               */
/*------------------------------------------------------*/

static double TP_Leme_tudo_bombordo_equal(double x) { return MF_xfl_triangle_equal(x, 1000.0, 2000.0, 1.0, 990.0, 1000.0, 1010.0); }

/*------------------------------------------------------*/
/* Description of the label bombordo                    */
/*------------------------------------------------------*/

static double TP_Leme_bombordo_equal(double x) { return MF_xfl_triangle_equal(x, 1000.0, 2000.0, 1.0, 1240.0, 1250.0, 1260.0); }

/*------------------------------------------------------*/
/* Description of the label centrado                    */
/*------------------------------------------------------*/

static double TP_Leme_centrado_equal(double x) { return MF_xfl_triangle_equal(x, 1000.0, 2000.0, 1.0, 1490.0, 1500.0, 1510.0); }

/*------------------------------------------------------*/
/* Description of the label estibordo                   */
/*------------------------------------------------------*/

static double TP_Leme_estibordo_equal(double x) { return MF_xfl_triangle_equal(x, 1000.0, 2000.0, 1.0, 1740.0, 1750.0, 1760.0); }

/*------------------------------------------------------*/
/* Description of the label tudo_estibordo              */
/*------------------------------------------------------*/

static double TP_Leme_tudo_estibordo_equal(double x) { return MF_xfl_triangle_equal(x, 1000.0, 2000.0, 1.0, 1990.0, 2000.0, 2010.0); }

/*======================================================*/
/*  Type TP_Vela                                        */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label cacada                      */
/*------------------------------------------------------*/

static double TP_Vela_cacada_equal(double x) { return MF_xfl_triangle_equal(x, 1000.0, 2000.0, 1.0, 990.0, 1000.0, 1010.0); }

/*------------------------------------------------------*/
/* Description of the label centrada                    */
/*------------------------------------------------------*/

static double TP_Vela_centrada_equal(double x) { return MF_xfl_triangle_equal(x, 1000.0, 2000.0, 1.0, 1490.0, 1500.0, 1510.0); }

/*------------------------------------------------------*/
/* Description of the label folgada                     */
/*------------------------------------------------------*/

static double TP_Vela_folgada_equal(double x) { return MF_xfl_triangle_equal(x, 1000.0, 2000.0, 1.0, 1990.0, 2000.0, 2010.0); }

/*======================================================*/
/*  Type TP_Roll                                        */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label aceitavel                   */
/*------------------------------------------------------*/

static double TP_Roll_aceitavel_equal(double x) { return MF_xfl_trapezoid_equal(x, 0.0, 90.0, 1.0, -30.0, 0.0, 30.0, 60.0); }

/*------------------------------------------------------*/
/* Description of the label critica                     */
/*------------------------------------------------------*/

static double TP_Roll_critica_equal(double x) { return MF_xfl_trapezoid_equal(x, 0.0, 90.0, 1.0, 30.0, 60.0, 90.0, 120.0); }

/*======================================================*/
/*  Rulebase RL_Leme                                    */
/*======================================================*/

static void RL_Leme(double angulo_correcao, double *Leme) {
  double _rl;

  double _Leme_degree[7];
  Consequent _Leme_conc[7];
  FuzzyNumber _Leme;
  _Leme.min = 1000.0;
  _Leme.max = 2000.0;
  _Leme.step = 1.0;
  _Leme.imp = OP__default__Imp;
  _Leme.also = OP__default__Also;
  _Leme.length = 7;
  _Leme.degree = _Leme_degree;
  _Leme.conc = _Leme_conc;
  int _Leme_i = 0;

  double _angulo_correcao_eq[7];
  _angulo_correcao_eq[0] = TP_angulo_correcao_tudo_esquerda_equal(angulo_correcao);
  _angulo_correcao_eq[1] = TP_angulo_correcao_esquerda_equal(angulo_correcao);
  _angulo_correcao_eq[2] = TP_angulo_correcao_pouco_esquerda_equal(angulo_correcao);
  _angulo_correcao_eq[3] = TP_angulo_correcao_centrado_equal(angulo_correcao);
  _angulo_correcao_eq[4] = TP_angulo_correcao_pouco_direita_equal(angulo_correcao);
  _angulo_correcao_eq[5] = TP_angulo_correcao_direita_equal(angulo_correcao);
  _angulo_correcao_eq[6] = TP_angulo_correcao_tudo_direita_equal(angulo_correcao);

  _rl = _angulo_correcao_eq[0];
  _Leme_degree[_Leme_i] = _rl;
  _Leme_conc[_Leme_i].equal = TP_Leme_tudo_bombordo_equal;
  _Leme_i++;

  _rl = _angulo_correcao_eq[1];
  _Leme_degree[_Leme_i] = _rl;
  _Leme_conc[_Leme_i].equal = TP_Leme_tudo_bombordo_equal;
  _Leme_i++;

  _rl = _angulo_correcao_eq[2];
  _Leme_degree[_Leme_i] = _rl;
  _Leme_conc[_Leme_i].equal = TP_Leme_bombordo_equal;
  _Leme_i++;

  _rl = _angulo_correcao_eq[3];
  _Leme_degree[_Leme_i] = _rl;
  _Leme_conc[_Leme_i].equal = TP_Leme_centrado_equal;
  _Leme_i++;

  _rl = _angulo_correcao_eq[4];
  _Leme_degree[_Leme_i] = _rl;
  _Leme_conc[_Leme_i].equal = TP_Leme_estibordo_equal;
  _Leme_i++;

  _rl = _angulo_correcao_eq[5];
  _Leme_degree[_Leme_i] = _rl;
  _Leme_conc[_Leme_i].equal = TP_Leme_tudo_estibordo_equal;
  _Leme_i++;

  _rl = _angulo_correcao_eq[6];
  _Leme_degree[_Leme_i] = _rl;
  _Leme_conc[_Leme_i].equal = TP_Leme_tudo_estibordo_equal;
  _Leme_i++;

  *Leme = OP__default__Defuz(_Leme);
}

/*======================================================*/
/*  Rulebase RL_Vela                                    */
/*======================================================*/

static void RL_Vela(double Roll, double Cata_vento, double *Vela) {
  double _rl;

  double _Vela_degree[6];
  Consequent _Vela_conc[6];
  FuzzyNumber _Vela;
  _Vela.min = 1000.0;
  _Vela.max = 2000.0;
  _Vela.step = 1.0;
  _Vela.imp = OP__default__Imp;
  _Vela.also = OP__default__Also;
  _Vela.length = 6;
  _Vela.degree = _Vela_degree;
  _Vela.conc = _Vela_conc;
  int _Vela_i = 0;

  double _Roll_eq[2];
  _Roll_eq[0] = TP_Roll_aceitavel_equal(Roll);
  _Roll_eq[1] = TP_Roll_critica_equal(Roll);

  double _Cata_vento_eq[3];
  _Cata_vento_eq[0] = TP_Cata_vento_proa_equal(Cata_vento);
  _Cata_vento_eq[1] = TP_Cata_vento_traves_equal(Cata_vento);
  _Cata_vento_eq[2] = TP_Cata_vento_re_equal(Cata_vento);

  _rl = OP__default__And(_Roll_eq[0], _Cata_vento_eq[0]);
  _Vela_degree[_Vela_i] = _rl;
  _Vela_conc[_Vela_i].equal = TP_Vela_folgada_equal;
  _Vela_i++;

  _rl = OP__default__And(_Roll_eq[0], _Cata_vento_eq[1]);
  _Vela_degree[_Vela_i] = _rl;
  _Vela_conc[_Vela_i].equal = TP_Vela_centrada_equal;
  _Vela_i++;

  _rl = OP__default__And(_Roll_eq[0], _Cata_vento_eq[2]);
  _Vela_degree[_Vela_i] = _rl;
  _Vela_conc[_Vela_i].equal = TP_Vela_cacada_equal;
  _Vela_i++;

  _rl = OP__default__And(_Roll_eq[1], _Cata_vento_eq[0]);
  _Vela_degree[_Vela_i] = _rl;
  _Vela_conc[_Vela_i].equal = TP_Vela_folgada_equal;
  _Vela_i++;

  _rl = OP__default__And(_Roll_eq[1], _Cata_vento_eq[1]);
  _Vela_degree[_Vela_i] = _rl;
  _Vela_conc[_Vela_i].equal = TP_Vela_folgada_equal;
  _Vela_i++;

  _rl = OP__default__And(_Roll_eq[1], _Cata_vento_eq[2]);
  _Vela_degree[_Vela_i] = _rl;
  _Vela_conc[_Vela_i].equal = TP_Vela_folgada_equal;
  _Vela_i++;

  *Vela = OP__default__Defuz(_Vela);
}

/*======================================================*/
/*                   Inference Engine                   */
/*======================================================*/

void Level1InferenceEngine(double angulo_correcao, double Cata_vento, double Roll, double *_d_Leme, double *_d_Vela) {
  double Leme;
  double Vela;
  RL_Leme(angulo_correcao, &Leme);
  RL_Vela(Roll, Cata_vento, &Vela);
  *_d_Leme = Leme;
  *_d_Vela = Vela;
}
